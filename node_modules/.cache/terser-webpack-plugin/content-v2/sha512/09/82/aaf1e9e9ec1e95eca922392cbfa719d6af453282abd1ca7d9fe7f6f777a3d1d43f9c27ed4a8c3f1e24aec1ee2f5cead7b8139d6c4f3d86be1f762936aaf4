{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{198:function(t,e,n){\"use strict\";n.r(e);var i=n(0),r=Object(i.a)({},(function(){var t=this.$createElement,e=this._self._c||t;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":this.$parent.slotKey}},[e(\"card\",{attrs:{title:\"我是home\",link:\"../views/home/Home.md\",content:\"\"}}),this._v(\" \"),e(\"card\",{attrs:{title:\"我是about\",link:\"../views/monacoEditor/monacoEditor.md\",content:\"\"}}),this._v(\" \"),e(\"card\",{attrs:{title:\"spa首屏计算方案\",link:\"../views/performance/performance.md\",content:\"对于首屏的定义，浏览器没有给出标准的指标，因为不同网站对于首屏的要求也是不尽相同的。我们从谷歌的第一次有效时间（first meaningfull paint）得到了一些启发，例如，一个新闻网站文字跟字体对于它来说是更重要的，而图片是次要的。新闻网站可以认为所有文字或字体加载出来即为首屏。但是对于电商网站来说，电商网站的图片可能更加重要，因为图片占据整个网站的80%以上。所以仅仅字体或文字被加载出来并不能定义为首屏时间。以此可以看出，首屏并不是一个可以通过简单的api就能计算出来的，首屏的方案也是因公司而异的。幸运的是，浏览器提供了各种监测性能及dom的api，可以让我们通过这些api来计算首屏时间。\"}}),this._v(\" \"),e(\"card\",{attrs:{title:\"vue\",link:\"../views/vue/vue.md\",content:\"\"}}),this._v(\" \"),e(\"card\",{attrs:{title:\"vue3\",link:\"../views/es6/proxy/readme.md\",content:\"vue3 源码正式放出来了，想必大家也都开始争先恐后的学习 vue3 的知识了。由于 vue3 已经不再支持 v-model 了，而使用 .sync 来代替，但是为了这篇文章可以帮助大家快速了解 vue 的双向绑定实现原理，部分使用了 vue2.x v-model 的实现原理\"}}),this._v(\" \"),e(\"card\",{attrs:{title:\"render函数-VS-动态component\",link:\"../views/vue/render/render.md\",content:\"大家应该都知道vue的render函数跟vue的动态组件，但是可能在90%的业务场景中都不会用到这方法，所以可能也不会去深究这些api的用法。这次正好有幸做了一次动态渲染组件的需求，小编就拿出来给大家分享一下。\"}})],1)}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}